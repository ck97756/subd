<html>
	<head>
		<title>WebGL SubD</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<style>
			body {
				background:#fff;
				color: #333;
				padding:0;
				margin:0;
				font-weight:bold;
				overflow:hidden;

				font-family:Monospace;
				font-size:13px;
				text-align:center;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index:100;
			}

			a {

				color: #0080ff;
			}

			b { color:orange }

			canvas { width: 100%; height: 100% }
		</style>

		<script src="three.js"></script>
		<script src="OrbitControls.js"></script>
	</head>
	<body>
		<div id="info"><a href="http://wadeb.com/">wadeb</a> - SubD<br/><br/>
		<b>0-4</b> smoothness, <b>A-B</b> switch model<br/>
		<b>C</b> control mesh, <b>V</b> verts, <b>W</b> wireframe<br/>
		</div>

		<script>
		/**
		 * @author wadeb / http://wadeb.com/
		 */

		// TODO:
		// + OBJ loader
		// + Make original face edges bold in wireframe
		//   Change it to iterate the edge list?  Or else change it to iterate the edge points, and save their influences in the SubD.
		//   Might want a view to show weighted influences for picked verts at some point too.
		// + Textures
		// + Texture coordinate smoothing
		// + Animate between levels

		var debugGeometry;
		var debugObjects = [];

		function addDebugLine(start, end) {
			var vert0 = new THREE.Vector3();
			var vert1 = new THREE.Vector3();

			vert0.copy(start);
			vert1.copy(end);

			debugGeometry.vertices.push(vert0);
			debugGeometry.vertices.push(vert1);
		}

		function addDebugObject(position, object) {
			object.position = position;
			debugObjects.push(object);
		}

		function roundRect(ctx, x, y, w, h, r) 
		{
		    ctx.beginPath();
		    ctx.moveTo(x+r, y);
		    ctx.lineTo(x+w-r, y);
		    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
		    ctx.lineTo(x+w, y+h-r);
		    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
		    ctx.lineTo(x+r, y+h);
		    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
		    ctx.lineTo(x, y+r);
		    ctx.quadraticCurveTo(x, y, x+r, y);
		    ctx.closePath();
		    ctx.fill();
			ctx.stroke();   
		}

		function makeTextSpriteMaterial(message, parameters)
		{
			parameters = parameters || {};
			var fontSize = parameters["fontSize"] || 18;			
			var fontFace = parameters["fontFace"] || "Arial";			
			var fontStyle = parameters["fontStyle"] || "Bold";			
			var padding = parameters["padding"] || 2;			
			var borderThickness = parameters["borderThickness"] || 8;			
			var borderStyle = parameters["borderStyle"] || "rgba(0, 0, 0, 1.0)";
			var backgroundStyle = parameters["backgroundStyle"] || "rgba(255, 255, 255, 1.0)";
			var textStyle = parameters["textStyle"] || "rgba(0, 0, 0, 1.0)";

			var size = 256;

			var canvas = document.createElement('canvas');
			canvas.width = size;
			canvas.height = size;

			var context = canvas.getContext('2d');
			
			context.font = fontStyle + " " + fontSize + "pt " + fontFace;
			var metrics = context.measureText(message);

			var width = metrics.width;
			var height = fontSize;

			context.strokeStyle = borderStyle;
			context.fillStyle = backgroundStyle;
			context.lineWidth = borderThickness;

			roundRect(context, 
				size/2 - width/2 - padding - borderThickness/2, 
				size/2 - height/2 - padding - borderThickness/2, 
				width + padding*2 + borderThickness, 
				height + padding*2 + borderThickness, 
				16);
			
			context.fillStyle = textStyle;
			context.fillText(message, size/2 - metrics.width/2, size/2 + fontSize/2);
			
			var texture = new THREE.Texture(canvas);
			texture.needsUpdate = true;

			var material = new THREE.SpriteMaterial({ 
				map: texture,
				uvOffset: new THREE.Vector2(-0.5, -0.5),
				depthTest: true
			});

			return material;
		}

		function makeTextSprite(size, material) {
			var sprite = new THREE.Sprite(material);
			sprite.scale = new THREE.Vector3(size, size, size);
			return sprite;
		}

		var vertKindSpriteMaterial = [
			makeTextSpriteMaterial("F", { fontSize: 100, padding: 4, backgroundStyle: "rgb(0,0,255)" }),
			makeTextSpriteMaterial("E", { fontSize: 100, padding: 4, backgroundStyle: "rgb(0,255,0)" }),
			makeTextSpriteMaterial("bE", { fontSize: 100, padding: 4, backgroundStyle: "rgb(0,255,0)" }),
			makeTextSpriteMaterial("V", { fontSize: 100, padding: 4, backgroundStyle: "rgb(255,0,0)" }),
			makeTextSpriteMaterial("bV", { fontSize: 100, padding: 4, backgroundStyle: "rgb(255,0,0)" }),
			makeTextSpriteMaterial("cV", { fontSize: 100, padding: 4, backgroundStyle: "rgb(255,0,0)" }),
		]

		var vertKindSize = [
			0.1, 0.1, 0.075, 0.1, 0.075, 0.075
		]

		function HalfEdge(faceIndex, vert0, vert1) {
			this.faceIndex = faceIndex;
			this.vert0 = vert0;
			this.vert1 = vert1;
			this.opposite = null;
			this.faceNext = null;
			this.facePrev = null;
			this.vertNext = null;
			this.vertPrev = null;
		}

		// The Quad Edge mesh is a useful data structure for navigating manifold topology.
		// For documentation, see http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html
		function QuadEdgeMesh(mesh) {
			this.faces = [];
			this.edges = [];
			this.edgeTable = {};
			this.vertEdges = [];
			this.faceEdges = [];
			this.vertCount = mesh.verts.length;

			for (var i = 0; i < mesh.faces.length; i++) {
				var face = mesh.faces[i];

				this.addFace(face);
			}

			this.finishEdges();
		}

		QuadEdgeMesh.prototype.makeEdgeHash = function(vert0, vert1) {
			return this.vertCount * vert0 + vert1;
		};

		QuadEdgeMesh.prototype.addFace = function(verts) {
			var faceIndex = this.faceEdges.length;

			var faceEdges = [];

			// Build array of half edges.
			for (var i = 0; i < verts.length; i++) {
				var vert0 = verts[i];
				var vert1 = verts[(i + 1) % verts.length];

				edge = new HalfEdge(faceIndex, vert0, vert1);
				this.edges.push(edge);

				faceEdges.push(edge);
			}

			// Insert edges into the hash table, indexed by start and end vertex.
			for (var i = 0; i < verts.length; i++) {
				var edge = faceEdges[i];

				var edgeHash = this.makeEdgeHash(edge.vert0, edge.vert1);

				if (this.edgeTable[edgeHash]) {
					throw "Non-manifold edge in input data between verts "+edge.vert0+" and "+edge.vert1;
				}

				this.edgeTable[edgeHash] = edge;
			}

			// Connect edges to their opposite half edge.
			// E.g. the same vertices but in the opposite direction.
			for (var i = 0; i < verts.length; i++) {
				var edge = faceEdges[i];

				var reverseEdgeHash = this.makeEdgeHash(edge.vert1, edge.vert0);
				var reverseEdge = this.edgeTable[reverseEdgeHash];

				if (reverseEdge) {
					edge.opposite = reverseEdge;
					reverseEdge.opposite = edge;
				}
			}
			
			// Connect edges to their neighbors on the same face.
			for (var i = 0; i < verts.length; i++) {
				var edge = faceEdges[i];

				edge.faceNext = faceEdges[(i + 1) % verts.length];
				edge.facePrev = faceEdges[(i + verts.length - 1) % verts.length];
			}

			// Store the first edge on the face.
			this.faceEdges.push(faceEdges[0]);
		};

		QuadEdgeMesh.prototype.finishEdges = function() {
			for (var i = 0; i < this.edges.length; i++) {
				var edge = this.edges[i];

				edge.vertNext = edge.facePrev.opposite;
				if (edge.opposite)
					edge.vertPrev = edge.opposite.faceNext;

				this.vertEdges[edge.vert0] = edge;
			}
		};

		THREE.FacePoint = 0;
		THREE.SmoothEdgePoint = 1;
		THREE.BorderEdgePoint = 2;
		THREE.SmoothVertPoint = 3;
		THREE.BorderVertPoint = 4;
		THREE.CornerVertPoint = 5;

		THREE.SubD = function(parameters) {
			parameters = parameters || {}
			this.verts = parameters["verts"] || [];
			this.faces = parameters["faces"] || [];

			this.facePointCount = 0;
			this.edgePointCount = 0;
			this.vertPointCount = this.verts.length;

			this.vertKinds = [];
			for (var i = 0; i < this.vertPointCount; i++)
				this.vertKinds[i] = THREE.CornerVertPoint;

			this.makeGeometry = function(parameters) {
				parameters = parameters || {}
				var flipWinding = parameters["flipWinding"] || false;

				var geometry = new THREE.Geometry();

				geometry.vertices = this.verts;

				// NB: This triangulation algorithm is insufficient for many kinds of polygons.  
				// See http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf for a better one.
				for (var i = 0; i < this.faces.length; i++) {
					var face = this.faces[i];
					if (flipWinding) {
						for (var j = 2; j < face.length; j++) {
							var face3 = new THREE.Face3(face[0], face[j], face[j-1]);
							geometry.faces.push(face3);
						}
					} else {
						for (var j = 2; j < face.length; j++) {
							var face3 = new THREE.Face3(face[0], face[j-1], face[j]);
							geometry.faces.push(face3);
						}
					}
				}

				geometry.mergeVertices();

				geometry.computeFaceNormals();
				geometry.computeVertexNormals();
				geometry.computeBoundingSphere();

				return geometry;
			}

			this.makeWireGeometry = function() {
				var geometry = new THREE.Geometry();

				for (var i = 0; i < this.faces.length; i++) {
					var face = this.faces[i];

					for (var j = 0; j < face.length; j++) {
						var vert0 = new THREE.Vector3();
						var vert1 = new THREE.Vector3();

						vert0.copy(this.verts[face[j]]);
						vert1.copy(this.verts[face[(j + 1) % face.length]]);

						geometry.vertices.push(vert0);
						geometry.vertices.push(vert1);
					}
				}

				geometry.computeLineDistances();

				return geometry;
			}

			this.Smooth = function(parameters) {
				parameters = parameters || {};
				var showVerts = parameters["showVerts"] || false;

				var qe = new QuadEdgeMesh(this);

				var smoothMesh = new THREE.SubD();

				// Calculate face points; centroid of face verts.
				for (var i = 0; i < qe.faceEdges.length; i++) {
					var facePoint = new THREE.Vector3();

					var edge = qe.faceEdges[i];
					var valence = 0;
					do {
						facePoint.add(this.verts[edge.vert0]);
						valence++;
						edge = edge.faceNext;
					} while (edge != qe.faceEdges[i]);

					facePoint.divideScalar(valence);

					smoothMesh.vertKinds.push(THREE.FacePoint);

					smoothMesh.verts.push(facePoint);
				}

				smoothMesh.facePointCount = qe.faceEdges.length;				

				// Calculate edge points; average of endpoints and adjacent face points for smooth,
				// average of end points if a border.
				for (var i = 0; i < qe.edges.length; i++) {
					var edge = qe.edges[i];

					edge.index = null;					
				}

				for (var i = 0; i < qe.edges.length; i++) {
					var edge = qe.edges[i];

					if (edge.index != null)
						continue;

					var edgePoint = new THREE.Vector3();
					edgePoint.copy(this.verts[edge.vert0]);
					edgePoint.add(this.verts[edge.vert1]);

					if (edge.opposite) {
						edgePoint.add(smoothMesh.verts[edge.faceIndex]);
						edgePoint.add(smoothMesh.verts[edge.opposite.faceIndex]);
						edgePoint.divideScalar(4.0);

						smoothMesh.vertKinds.push(THREE.SmoothEdgePoint);
					} else {
						edgePoint.divideScalar(2.0);

						smoothMesh.vertKinds.push(THREE.BorderEdgePoint);
					}

					edge.index = smoothMesh.verts.length;
					if (edge.opposite)
						edge.opposite.index = edge.index;

					smoothMesh.verts.push(edgePoint);
				}

				smoothMesh.edgePointCount = smoothMesh.verts.length - smoothMesh.facePointCount;

				// Calculate vertex points; weighted average of adjacent vertices and face points,
				// unless border or corner rules apply.
				var firstVertPoint = smoothMesh.verts.length;

				for (var i = 0; i < qe.vertCount; i++) {
					var firstEdge = qe.vertEdges[i];
					do {
						if (firstEdge.vertPrev)
							firstEdge = firstEdge.vertPrev;
					} while (firstEdge.vertPrev && firstEdge != qe.vertEdges[i]);

					var borderEdges = [];
					var valence = 0;
					var edge = firstEdge;
					do {
						if (edge.vertPrev == null || edge.vertNext == null)
							borderEdges.push(edge);
						valence += 1;
						edge = edge.vertNext;
					} while (edge && edge != firstEdge);

					var vertPoint = new THREE.Vector3();
					vertPoint.copy(this.verts[i]);

					if (borderEdges.length > 2 || valence == 1) {
						smoothMesh.vertKinds.push(THREE.CornerVertPoint);
					} else if (borderEdges.length == 2) {
						var borderVert0 = new THREE.Vector3();
						borderVert0.copy(this.verts[borderEdges[0].vert1]);

						var borderVert1 = new THREE.Vector3();
						borderVert1.copy(this.verts[borderEdges[1].facePrev.vert0]);

						vertPoint.multiplyScalar(6.0/8.0)
						borderVert0.multiplyScalar(1.0/8.0);
						borderVert1.multiplyScalar(1.0/8.0);

						vertPoint.add(borderVert0);
						vertPoint.add(borderVert1);

						smoothMesh.vertKinds.push(THREE.BorderVertPoint);
					} else {
						var neighborSum = new THREE.Vector3();
						var faceSum = new THREE.Vector3();

						var edge = firstEdge;
						do {
							neighborSum.add(this.verts[edge.vert1]);
							faceSum.add(smoothMesh.verts[edge.faceIndex]);
							edge = edge.vertNext;
						} while (edge != firstEdge);

						var baseScalar = (valence - 2.0) / valence;
						var neighborScalar = 1.0 / (valence * valence);

						vertPoint.multiplyScalar(baseScalar);
						neighborSum.multiplyScalar(neighborScalar);
						faceSum.multiplyScalar(neighborScalar);

						vertPoint.add(neighborSum);
						vertPoint.add(faceSum);

						smoothMesh.vertKinds.push(THREE.SmoothVertPoint);
					}

					smoothMesh.verts.push(vertPoint);
				}

				smoothMesh.vertPointCount = qe.vertCount;

				// Build new faces from face points, edge points and vertex points.
				for (var i = 0; i  < qe.faceEdges.length; i++) {
					var firstEdge = qe.faceEdges[i];
					var edge = firstEdge;
					do {
						smoothMesh.faces.push([ 
							i, 
							edge.facePrev.index, 
							firstVertPoint + edge.vert0, 
							edge.index
						]);
						edge = edge.faceNext;
					} while (edge != firstEdge);
				}

				return smoothMesh;
			}

			this.forEachFacePoint = function(callback) {
				for (var i = 0; i < this.facePointCount; i++)
					callback(this.verts[i]);
			}

			this.forEachEdgePoint = function(callback) {
				for (var i = 0; i < this.edgePointCount; i++)
					callback(this.verts[this.facePointCount + i]);
			}

			this.forEachVertPoint = function(callback) {
				for (var i = 0; i < this.vertPointCount; i++)
					callback(this.verts[this.facePointCount + this.edgePointCount + i]);
			}
		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author wadeb / http://wadeb.com/
		 */

		THREE.SubDOBJLoader = function ( manager ) {

			this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		};

		THREE.SubDOBJLoader.prototype = {

			constructor: THREE.SubDOBJLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new THREE.XHRLoader( scope.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( text ) );

				} );

			},

			parse: function ( text ) {

				var mesh = new THREE.SubD();

				function parseVertexIndex( value ) {

					var index = parseInt( value );

					return ( index >= 0 ? index - 1 : index + mesh.verts.length );

				}

				function parseUVIndex( value ) {

					var index = parseInt( value );

					return ( index >= 0 ? index - 1 : index + mesh.uvs.length );

				}

				// v float float float

				var vertex_pattern = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

				// vn float float float

				var normal_pattern = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

				// vt float float

				var uv_pattern = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

				// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...

				var face_vert_pattern = / +(-?\d+)(\/(-?\d+)?)?(\/(-?\d+)?)?/;

				//

				var lines = text.split( '\n' );

				for ( var i = 0; i < lines.length; i ++ ) {

					var line = lines[ i ];
					line = line.trim();

					var result;

					if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

						continue;

					} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {

						// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

						mesh.verts.push(
							new THREE.Vector3(
								parseFloat( result[ 1 ] ),
								parseFloat( result[ 2 ] ),
								parseFloat( result[ 3 ] )
							)
						);

					} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {

						// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

					} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {

						// ["vt 0.1 0.2", "0.1", "0.2"]

						// mesh.uvs.push(
						// 	parseFloat( result[ 1 ] ),
						// 	parseFloat( result[ 2 ] )
						// );

					} else if ( /^f /.test( line ) ) {

						var faceVerts = [];
						// var faceUVs = [];

						line = line.substring( 1 );

						while ( ( result = face_vert_pattern.exec( line ) ) != null ) {

							// [" 0/1/2", "0", "/1", "1", "/2", "2"]

							faceVerts.push( parseVertexIndex( result[ 1 ] ) );
							// faceUVs.push( parseUVIndex( result[ 3 ] ) );

							line = line.substring( result[ 0 ].length );
						}

						mesh.faces.push( faceVerts );

					} else if ( /^o /.test( line ) ) {

						// object

					} else if ( /^g /.test( line ) ) {

						// group

					} else if ( /^usemtl /.test( line ) ) {

						// material

					} else if ( /^mtllib /.test( line ) ) {

						// mtl file

					} else if ( /^s /.test( line ) ) {

						// smooth shading

					} else {

						// console.log( "THREE.OBJLoader: Unhandled line " + line );

					}

				}

				return mesh;

			}

		};

		var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.x = -3;
		camera.position.y = 3;
		camera.position.z = 4;

		var renderer = new THREE.WebGLRenderer({ "antialias": true });
		renderer.setClearColor("antiquewhite", 1);
		renderer.setSize(window.innerWidth, window.innerHeight);
		// renderer.shadowMapEnabled = true;
		// renderer.shadowMapSoft = true;
		document.body.appendChild(renderer.domElement);

		var cylinderSubD = new THREE.SubD({
			verts: [
				new THREE.Vector3(-1, -1, -1),
				new THREE.Vector3(-1, -1, 1),
				new THREE.Vector3(-1, 1, -1),
				new THREE.Vector3(-1, 1, 1),
				new THREE.Vector3(1, -1, -1),
				new THREE.Vector3(1, -1, 1),
				new THREE.Vector3(1, 1, -1),
				new THREE.Vector3(1, 1, 1)
			],
			faces: [
				[ 0, 1, 3, 2 ],
				[ 4, 0, 2, 6 ],
				[ 5, 4, 6, 7 ],
				[ 1, 5, 7, 3 ],
			]
		});

		var tetrahedronSubD = new THREE.SubD({
			verts: [
				new THREE.Vector3(-2, -2, -2),
				new THREE.Vector3(2, 2, -2),
				new THREE.Vector3(-2, 2, 2),
				new THREE.Vector3(2, -2, 2),
			],
			faces: [
				[ 1, 2, 3 ],
				[ 0, 3, 2 ],
				[ 0, 2, 1 ],
				[ 0, 1, 3 ],
			]
		});

		var subds = [ cylinderSubD ];

		var manager = new THREE.LoadingManager();
		manager.onProgress = function ( item, loaded, total ) {
			console.log( item, loaded, total );
		};

		// var texture = new THREE.Texture();
		// var loader = new THREE.ImageLoader( manager );
		// loader.load( 'textures/UV_Grid_Sm.jpg', function ( image ) {
		// 	texture.image = image;
		// 	texture.needsUpdate = true;
		// } );

		var loader = new THREE.SubDOBJLoader( manager );
		loader.load( 'http://wadeb.com/subd/monsterfrog_cage0.obj', function ( subd ) {
			subds.push( subd );
		} );

		var subdMaterial = new THREE.MeshPhongMaterial( { ambient: 0xffffff, color: 0xdddddd, specular: 0 } );
		var subdInsideMaterial = new THREE.MeshPhongMaterial( { ambient: 0x303030, color: 0xdddddd, specular: 0 } );

		var subdWireMaterial = new THREE.LineBasicMaterial({ color: 0x404040 });
		var controlWireMaterial = new THREE.LineBasicMaterial({ color: 0x008000 });
		var debugMaterial = new THREE.LineBasicMaterial({ color: 0x800000 });

		var enableControlGeometry = true;
		var enableWireframe = false;
		var enableVerts = false;
		var smoothLevel = 4;
		var modelIndex = 0;

		var scene = null;

		var buildScene = function() {
			scene = new THREE.Scene();

			var light = new THREE.AmbientLight(0x808080);
			scene.add(light);

			if (0) {
				var light = new THREE.SpotLight(0xe0e0e0);
				light.position.set(5, 5, 5);
				light.target.position.set( 0, 0, 0 );
				// light.castShadow = true;
				// light.shadowCameraNear = 6;
				// light.shadowCameraFar = 10;
				// light.shadowCameraFov = 30;
				// light.shadowDarkness = 1;
				// light.shadowCameraVisible = true;
				// light.shadowMapWidth = 1024;
				// light.shadowMapHeight = 1024;
				scene.add(light);
			} else {
				var light = new THREE.DirectionalLight(0xe0e0e0, 0.5);
				light.position.set(10, 10, 10);
				light.target.position.set( 0, 0, 0 );
				// light.castShadow = true;
				// light.shadowCameraNear = 10;
				// light.shadowCameraFar = 30;
				// light.shadowCameraRight = 10;
				// light.shadowCameraLeft = -10;
				// light.shadowCameraTop = -10;
				// light.shadowCameraBottom = 10;
				// light.shadowDarkness = 0.5;
				// light.shadowCameraVisible = true;
				// light.shadowMapWidth = 2048;
				// light.shadowMapHeight = 2048;
				scene.add(light);
			}

			debugGeometry = new THREE.Geometry();
			debugObjects = [];

			var model = subds[modelIndex];

			if (enableControlGeometry) {
				var controlWireGeometry = model.makeWireGeometry();
				var controlWireObject = new THREE.Line(controlWireGeometry, controlWireMaterial, THREE.LinePieces);
				scene.add(controlWireObject);
			}

			var subdMesh = model;
			for (var i = 0; i < smoothLevel; i++)
				subdMesh = subdMesh.Smooth();

			var subdGeometry = subdMesh.makeGeometry();
			var subdObject = new THREE.Mesh(subdGeometry, subdMaterial);
			// subdObject.castShadow = true;
			// subdObject.receiveShadow = false;
			scene.add(subdObject);				

			var subdInsideGeometry = subdMesh.makeGeometry({ flipWinding: true });
			var subdInsideObject = new THREE.Mesh(subdInsideGeometry, subdInsideMaterial);
			// subdInsideObject.castShadow = true;
			// subdInsideObject.receiveShadow = true;
			scene.add(subdInsideObject);				

			if (enableVerts) {
				for (var i = 0; i < subdMesh.verts.length; i++) {
					var vert = subdMesh.verts[i];
					var kind = subdMesh.vertKinds[i];
					addDebugObject(vert, makeTextSprite(vertKindSize[kind], vertKindSpriteMaterial[kind]));
				}
			}

			if (enableWireframe) {
				var subdWireGeometry = subdMesh.makeWireGeometry();
				var subdWireObject = new THREE.Line(subdWireGeometry, subdWireMaterial, THREE.LinePieces);
				scene.add(subdWireObject);
			}

			// var plane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10, 1, 1), subdMaterial);
			// plane.rotateOnAxis(new THREE.Vector3(1, 0, 0), -3.14159/2);
			// plane.translateOnAxis(new THREE.Vector3(0, 0, 1), -1.0);
			// plane.receiveShadow = true;
			// scene.add(plane);

			for (var i = 0; i < debugObjects.length; i++)
				scene.add(debugObjects[i]);

			if (debugGeometry.vertices.length) {
				var debugObject = new THREE.Line(debugGeometry, debugMaterial, THREE.LinePieces);
				scene.add(debugObject);
			}
		}

		var render = function() {
			if (scene)
				renderer.render(scene, camera);
		}

		controls = new THREE.OrbitControls(camera);
		controls.update();
		controls.addEventListener('change', render);

		var onKeyDown = function() {
			switch( event.keyCode ) {
				case 48: /*0*/ smoothLevel = 0; break;
				case 49: /*1*/ smoothLevel = 1; break;
				case 50: /*2*/ smoothLevel = 2; break;
				case 51: /*3*/ smoothLevel = 3; break;
				case 52: /*4*/ smoothLevel = 4; break;
				case 65: /*a*/ modelIndex = 0; break;
				case 66: /*b*/ modelIndex = 1; break;
				case 67: /*c*/ enableControlGeometry = !enableControlGeometry; break;
				case 83: /*s*/ enableSubD = !enableSubD; break;
				case 86: /*v*/ enableVerts = !enableVerts; break;
				case 87: /*w*/ enableWireframe = !enableWireframe; break;
				default: return;
			}
			buildScene();
			render();
		}

		window.addEventListener( 'keydown', onKeyDown, false );

		var onWindowResize = function() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();
		}

		window.addEventListener( 'resize', onWindowResize, false );

		buildScene();
		render();
		</script>
	</body>
</html>